<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RL in Constraint Manifold | Arvin</title><meta name="author" content="Arvin"><meta name="copyright" content="Arvin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文档维护：Arvin 网页部署：Arvin ▶ Abstract由于许多实际问题，包括安全、机械约束和磨损，机器人技术中的强化学习极具挑战性。 通常，这些问题在机器学习文献中没有被考虑。在现实世界中应用强化学习的一个关键问题是安全探索，这需要在整个学习过程中满足物理和安全约束。为了在这样一个安全关键的环境中进行探索，利用机器人模型和约束等已知信息有助于提供更强大的安全保证。利用这些知识，我们提出了">
<meta property="og:type" content="article">
<meta property="og:title" content="RL in Constraint Manifold">
<meta property="og:url" content="http://example.com/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/index.html">
<meta property="og:site_name" content="Arvin">
<meta property="og:description" content="文档维护：Arvin 网页部署：Arvin ▶ Abstract由于许多实际问题，包括安全、机械约束和磨损，机器人技术中的强化学习极具挑战性。 通常，这些问题在机器学习文献中没有被考虑。在现实世界中应用强化学习的一个关键问题是安全探索，这需要在整个学习过程中满足物理和安全约束。为了在这样一个安全关键的环境中进行探索，利用机器人模型和约束等已知信息有助于提供更强大的安全保证。利用这些知识，我们提出了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png">
<meta property="article:published_time" content="2023-08-27T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-19T08:41:00.181Z">
<meta property="article:author" content="Arvin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RL in Constraint Manifold",
  "url": "http://example.com/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/",
  "image": "https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png",
  "datePublished": "2023-08-27T16:00:00.000Z",
  "dateModified": "2025-08-19T08:41:00.181Z",
  "author": [
    {
      "@type": "Person",
      "name": "Arvin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/my-icon.png"><link rel="canonical" href="http://example.com/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RL in Constraint Manifold',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/nacho.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/my-icon.png" alt="Logo"><span class="site-name">Arvin</span></a><a class="nav-page-title" href="/"><span class="site-name">RL in Constraint Manifold</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RL in Constraint Manifold</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-27T16:00:00.000Z" title="发表于 2023-08-28 00:00:00">2023-08-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-19T08:41:00.181Z" title="更新于 2025-08-19 16:41:00">2025-08-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>文档维护：<code>Arvin</code></p>
<p>网页部署：<code>Arvin</code></p>
<p>▶</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>由于许多实际问题，包括安全、机械约束和磨损，机器人技术中的强化学习极具挑战性。</p>
<p>通常，这些问题在机器学习文献中没有被考虑。在现实世界中应用强化学习的一个关键问题是安全探索，这需要在整个学习过程中满足物理和安全约束。为了在这样一个安全关键的环境中进行探索，利用机器人模型和约束等已知信息有助于提供更强大的安全保证。利用这些知识，我们提出了一种新的方法，在满足学习过程中的约束的情况下，有效地学习仿真中的机器人任务。</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>深度强化学习虽然在一些问题上表现的很好，但是在现实世界中使用强化学习还是一项具有挑战性的任务，因为典型的强化学习算法，通过不断试错来最大化累计奖励，并没有考虑在探索过程中对约束的满足，而在实际世界中智能体在探索过程中要受到许多约束。</p>
<p>文章提出了一种新方法，在流形空间的切平面上执行动作（Acting on the Tangent Space of the Constraint Manifold, ATACOM）。该方法将约束强化学习问题转化成无约束强化学习问题。</p>
<p>ATACOM的优势可以概括如下:</p>
<ul>
<li>可以处理等式约束和不等式约束。在整个学习过程中，每个时间步的都在约束范围内。</li>
<li>不需要初始可行策略，智能体可以从零开始学习。</li>
<li>不需要手动将系统移回安全区域的安全备份策略。</li>
<li>可以应用于任何无模型RL算法，使用确定性和随机策略。</li>
<li>可以将探索的重点放在低维流形上，而不是在原来的行动空间中探索等式约束问题。</li>
<li>由于不等式约束约束在更小的可行状态-动作空间内，学习性能更好。</li>
</ul>
<p>缺点:</p>
<ul>
<li>可微的约束函数。</li>
<li>机器人足够精确的可逆动力学模型或性能良好的跟踪控制器。</li>
</ul>
<h1 id="Learning-on-the-Constraint-Manifold"><a href="#Learning-on-the-Constraint-Manifold" class="headerlink" title="Learning on the Constraint Manifold"></a>Learning on the Constraint Manifold</h1><p><img src="/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png" alt="1"></p>
<p><strong>参数</strong>：<br>$q$：状态变量</p>
<p>$a=\boldsymbol{\Lambda}(\dot{\boldsymbol{q}})$：速度</p>
<p>$a=\boldsymbol\Lambda({\ddot{\boldsymbol{q}}})$：加速度</p>
<p>其中，在机器人的角度看，这个$a$可以是施加在每个关节上的扭矩，$\Lambda $是逆动力学模型。</p>
<p><strong>带约束的马尔可夫过程CMDP</strong>:<br>CMDP是一个元组$(\mathcal{S},\mathcal{A},P,R,\gamma,\mathcal{C})$，其中</p>
<ul>
<li>$\mathcal{S}$：状态空间</li>
<li>$\mathcal{A}$：动作空间</li>
<li>$P$：$\mathcal{S}\times\mathcal{A}\times\mathcal{S}\rightarrow[0,1]$，转移核，类似于状态转移概率矩阵？</li>
<li>$R$：奖励</li>
<li>$\gamma$：折扣因子</li>
<li>$\mathcal{C}$：$\{c_{i}:\mathcal{S}\to\mathbb{R}|i\in1,…,k\}$，当前状态约束函数的集合</li>
</ul>
<p><strong>假设</strong>：<br>本文将状态变量$s\in\mathcal{S}$分解为直接可控状态$q\in\mathcal{Q}$和不可控状态$x\in\mathcal{X}$，即$\boldsymbol{s}=\left[\begin{array}{ll}\boldsymbol{q} &amp; \boldsymbol{x}\end{array}\right]^{\top}$。并作出如下假设：</p>
<ul>
<li>假设约束$c(\boldsymbol{q})\leq 0$是已知的，并且完全依赖于可控状态</li>
<li>假设动作$a$可以根据可控状态的$i$阶时间导数确定，即$\boldsymbol{a}=\boldsymbol{\Lambda}(\boldsymbol{q}^{(i)}), i \in \{1,2,…\}$</li>
</ul>
<p>约束强化学习问题的一般形式可以表示为：</p>
<script type="math/tex; mode=display">
\max_{\boldsymbol{\theta}}\mathbb{E}_{\boldsymbol{s}_t,\boldsymbol{a}_t}\left[\sum_{t=0}^T\gamma^tr(\boldsymbol{s}_t,\boldsymbol{a}_t)\right],\quad\text{s.t.}\quad\boldsymbol{c}(\boldsymbol{q}_t)\leq\boldsymbol{0}</script><h2 id="State-Constraints"><a href="#State-Constraints" class="headerlink" title="State Constraints"></a>State Constraints</h2><p>状态约束定义为：</p>
<script type="math/tex; mode=display">
f(\boldsymbol{q})=\boldsymbol{0},\quad\boldsymbol{g}(\boldsymbol{q})\leq\boldsymbol{0} \tag{1}</script><p>这里，$f:\mathbb{R}^Q\to\mathbb{R}^F,g:\mathbb{R}^Q\to\mathbb{R}^G$是等式约束$F$和不等式约束$G$的连续二阶可导$C^2$映射，并且$F&lt;Q$，即等式约束的数量F少于Q，也就是说等式约束的个数比问题中自变量个数要少。并且加入松弛变量$\mu\in\mathbb{R}^{G}$，将上式转化为等式约束：</p>
<script type="math/tex; mode=display">
c(\boldsymbol{q},\boldsymbol{\mu})=\begin{bmatrix}f(\boldsymbol{q})&\boldsymbol{g}(\boldsymbol{q})+\frac12\boldsymbol{\mu}^2\end{bmatrix}^\mathsf{T}=\mathbf{0} \tag{2}</script><p>此约束集合是嵌入在$(Q+G)$维空间中的$(F+G)$维流形。</p>
<p>计算其时间导数：</p>
<script type="math/tex; mode=display">
\dot{\boldsymbol{c}}(\boldsymbol{q},\boldsymbol{\mu},\dot{\boldsymbol{q}},\dot{\boldsymbol{\mu}})=\begin{bmatrix}\boldsymbol{J}_f(\boldsymbol{q})&0\\\boldsymbol{J}_g(\boldsymbol{q})&\operatorname{diag}(\boldsymbol{\mu})\end{bmatrix}\begin{bmatrix}\dot{\boldsymbol{q}}\\\dot{\boldsymbol{\mu}}\end{bmatrix}=\boldsymbol{J}_c(\boldsymbol{q},\boldsymbol{\mu})\begin{bmatrix}\dot{\boldsymbol{q}}\\\dot{\boldsymbol{\mu}}\end{bmatrix} \tag{3}</script><p>$f(\boldsymbol{q})$和$f(\boldsymbol{q})$的雅可比矩阵$J_f\in\mathbb{R}^{F\times Q}$和$J_g\in\mathbb{R}^{G\times Q}$。将两个雅可比矩阵组合成完全约束集的雅可比矩阵$\boldsymbol{J}_{c}(\boldsymbol{q},\boldsymbol{\mu})\in\mathbb{R}^{(F+G)\times(Q+G)}$。</p>
<p>我们可以通过 <em>SVD</em> 分解或 <em>QR</em> 分解得到零空间矩阵$\boldsymbol{N}_{c}(\boldsymbol{q},\boldsymbol{\mu})=\mathrm{Null}[\boldsymbol{J}_{c}(\boldsymbol{q},\boldsymbol{\mu})]\in\mathbb{R}^{(Q+G)\times(Q-F)}$，使得$\boldsymbol{J}_{c}(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{N}_{c}(\boldsymbol{q},\boldsymbol{\mu})=\boldsymbol{0}$。正交矩阵$\boldsymbol{N}_{c}(\boldsymbol{q},\boldsymbol{\mu})$的每一列表示$\boldsymbol{J}_{c}(\boldsymbol{q},\boldsymbol{\mu})$的零空间的一个基向量。这些零空间基也可以看作约束流形的切空间基，如图1所示。我们可以用坐标$\alpha$来构造约束流形的切空间速度。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}\dot{\boldsymbol{q}}\tau\\\dot{\boldsymbol{\mu}}\tau\end{bmatrix}=N_c(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{\alpha} \tag{4}</script><p>将公式（3）中的$[\dot{q}\quad\dot{\mu}]^{\mathsf{T}}$替换成（4）中的$[\dot{q}_{\mathcal{T}}\quad\dot{\mu}_{\mathcal{T}}]^{\mathsf{T}}$，则有</p>
<script type="math/tex; mode=display">
\dot{c}(\boldsymbol{q},\boldsymbol{\mu},\dot{\boldsymbol{q}},\dot{\boldsymbol{\mu}})=\boldsymbol{J}_c(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{N}_c(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{\alpha}=\boldsymbol{0} \tag{5}</script><p>方程（5）表明，无论$\alpha$的选择如何，约束都不会改变。基于这一概念，<em>ATACOM</em>方法可以概括为:从可行点出发$(\boldsymbol{q}(0),\boldsymbol{\mu}(0))\in\{(\boldsymbol{q},\boldsymbol{\mu})|\boldsymbol{c}(\boldsymbol{q},\boldsymbol{\mu})=\boldsymbol{0}\}$,我们选择切线空间速度$[\dot{\boldsymbol{q}}_{\mathcal{T}}(t),\dot{\boldsymbol{\mu}}_{\mathcal{T}}(t)]^{\mathsf{T}}={\boldsymbol{N}}_{c}(\boldsymbol{q}(t),\boldsymbol{\mu}(t))\boldsymbol{\alpha}(t)$和相应的行动$\boldsymbol{a}(t)=\boldsymbol{\Lambda}(\dot{\boldsymbol{q}}_{\mathcal{T}}(t))$。从而将约束RL问题转化为无约束RL问题。得到的轨迹$q(t)$满足约束条件$\boldsymbol{c}(\boldsymbol{q}(t),\boldsymbol{\mu}(t))=\mathbf{0}$。</p>
<p><img src="/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/2.png" alt="2"></p>
<h2 id="Viability-Constraints"><a href="#Viability-Constraints" class="headerlink" title="Viability Constraints"></a>Viability Constraints</h2><p>对于物理系统，通常需要一个连续的速度命令。然而，直接采样速度 $\dot q$ 并不能保证这种连续性。一个简单的解决方案是采样加速度，对系统施加力或通过积分确定速度。此外，在考虑不等式约束时，也希望当 $g(q)=0$ 时，$\dot g(q, \dot q) \le 0$，以避免过冲。</p>
<p>我们将原始状态约束(1)转换为受线性可行性条件启发的可行性约束：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{f}(\boldsymbol{q})+\boldsymbol{K}_{f} \dot{\boldsymbol{f}}(\boldsymbol{q}, \dot{\boldsymbol{q}}) & =\boldsymbol{f}(\boldsymbol{q})+\boldsymbol{K}_{f} \boldsymbol{J}_{f}(\boldsymbol{q}) \dot{\boldsymbol{q}}=\mathbf{0} \\
\boldsymbol{g}(\boldsymbol{q})+\boldsymbol{K}_{g} \dot{\boldsymbol{g}}(\boldsymbol{q}, \dot{\boldsymbol{q}}) & =\boldsymbol{g}(\boldsymbol{q})+\boldsymbol{K}_{g} \boldsymbol{J}_{g}(\boldsymbol{q}) \dot{\boldsymbol{q}} \leq \mathbf{0}
\end{aligned}    \tag{6}</script><p>对角矩阵$K_f \in \mathbb{R}^{F\times F}, K_{g}\in\mathbb{R}^{G\times G}$均为正项。矩阵$K_f$和$K_g$决定了约束$\dot f$和$\dot g$的最大速度与约束值的比值。</p>
<p>不等式约束的可行性约束如图2所示。当$g(q) &lt; 0$时，约束速度的上界为$\dot g_{max} &gt; 0$，表明仍有可能接近约束边界。然而，当$g(q) &gt; 0$时，约束速度$\dot g_{max}$的上界应小于零。</p>
<p>与式(2)和式(3)的推导类似，我们有：</p>
<script type="math/tex; mode=display">
c(\boldsymbol{q},\dot{\boldsymbol{q}},\boldsymbol{\mu})=\begin{bmatrix}\boldsymbol{f}(\boldsymbol{q})+\boldsymbol{K}_f\boldsymbol{J}_f(\boldsymbol{q})\dot{\boldsymbol{q}}\\\boldsymbol{g}(\boldsymbol{q})+\boldsymbol{K}_g\boldsymbol{J}_g(\boldsymbol{q})\dot{\boldsymbol{q}}+\frac12\boldsymbol{\mu}^2\end{bmatrix}=\mathbf{0}    \tag{7}</script><script type="math/tex; mode=display">
\dot{\boldsymbol{c}}(\boldsymbol{q},\dot{\boldsymbol{q}},\ddot{\boldsymbol{q}},\boldsymbol{\mu},\dot{\boldsymbol{\mu}})=\underbrace{\begin{bmatrix}\boldsymbol{K}_f\boldsymbol{J}_f(\boldsymbol{q})&\boldsymbol{0}\\\boldsymbol{K}_g\boldsymbol{J}_g(\boldsymbol{q})&\mathrm{diag}(\boldsymbol{\mu})\end{bmatrix}}_{\boldsymbol{J}_c(\boldsymbol{q},\boldsymbol{\mu})}\begin{bmatrix}\ddot{\boldsymbol{q}}\\\dot{\boldsymbol{\mu}}\end{bmatrix}+\underbrace{\begin{bmatrix}\boldsymbol{J}_f(\boldsymbol{q})\dot{\boldsymbol{q}}+\boldsymbol{K}_f\boldsymbol{b}_f(\boldsymbol{q},\dot{\boldsymbol{q}})\\\boldsymbol{J}_g(\boldsymbol{q})\dot{\boldsymbol{q}}+\boldsymbol{K}_g\boldsymbol{b}_g(\boldsymbol{q},\dot{\boldsymbol{q}})\end{bmatrix}}_{\psi(\boldsymbol{q},\dot{\boldsymbol{q}})}=\boldsymbol{0}    \tag{8}</script><p>式中$\boldsymbol{b}_f(\boldsymbol{q},\dot{\boldsymbol{q}})=\dot{\boldsymbol{q}}^\mathsf{T}\boldsymbol{H}_f(\boldsymbol{q})\dot{\boldsymbol{q}}$, $\boldsymbol{b}_g(\boldsymbol{q},\dot{\boldsymbol{q}})=\dot{\boldsymbol{q}}^\mathsf{T}\boldsymbol{H}_g(\boldsymbol{q})\dot{\boldsymbol{q}}$, $\boldsymbol{H}_f\in\mathbb{R}^{F\times Q\times Q},\boldsymbol{H}_g(\boldsymbol{q})\in\mathbb{R}^{G\times Q\times Q}$分别为$f(q)、g(q)$的Hessians矩阵。我们可以构造关节加速度为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}\ddot{\boldsymbol{q}}\\\dot{\boldsymbol{\mu}}\end{bmatrix}=-\boldsymbol{J}_c^\dagger(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{\psi}(\boldsymbol{q},\dot{\boldsymbol{q}})+\boldsymbol{N}_c(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{\alpha}    \tag{9}</script><p>分别用雅可比矩阵$J_c(\boldsymbol{q},\boldsymbol{\mu})$的伪逆$J_{c}^{\dagger}(\boldsymbol{q},\boldsymbol{\mu})$和零空间矩阵$\boldsymbol{N}_c(\boldsymbol{q},\boldsymbol{\mu})$。方程(9)中的第一项是维持约束流形(7)曲率的必要加速度，第二项是约束的切空间加速度。</p>
<p>当从点$[\boldsymbol{q}(0),\dot{\boldsymbol{q}}(0),\boldsymbol{\mu}(0)]\in\{(\boldsymbol{q},\dot{\boldsymbol{q}},\boldsymbol{\mu})|\boldsymbol{c}(\boldsymbol{q},\dot{\boldsymbol{q}},\boldsymbol{\mu})=\boldsymbol{0}\}$开始，在$\alpha$上采样时，关节加速度$\ddot{q}$和相应的动作$a$满足约束条件。</p>
<h2 id="Viability-Acceleration-Bound"><a href="#Viability-Acceleration-Bound" class="headerlink" title="Viability Acceleration Bound"></a>Viability Acceleration Bound</h2><p>在机器人和其他机械系统中，考虑执行器的速度约束是很重要的。此外，加速度应该适当地有界，以避免超调。我们再次使用可行性的概念来确定加速度的上界和下界:</p>
<script type="math/tex; mode=display">
\boldsymbol{a}_{u}=\max\left(\min\left(\boldsymbol{a}_{\max},-\boldsymbol{K}_{a}(\boldsymbol{q}-\boldsymbol{v}_{\max})\right),\boldsymbol{a}_{\min}\right)</script><script type="math/tex; mode=display">
\boldsymbol{a}_{l}=\min\left(\max\left(\boldsymbol{a}_{\min},-\boldsymbol{K}_{a}\left(\boldsymbol{q}-\boldsymbol{v}_{\min}\right)\right),\boldsymbol{a}_{\max}\right)</script><p>以最小和最大关节速度极限$v_{min,max}$和加速度极限$a_{min,max}$，$K_a &gt; 0$为常数。可行加速度区域如图3所示。与可行性约束类似，加速度的可行区域根据关节速度的状态进行修改。这种技术有效地防止了超调。</p>
<h2 id="Error-Correction-and-Control-Action-Selection"><a href="#Error-Correction-and-Control-Action-Selection" class="headerlink" title="Error Correction and Control Action Selection"></a>Error Correction and Control Action Selection</h2><p>对于时间连续系统，以一定的采样率获得状态，并应用周期一定的动作。这种时间离散化导致每个时间步上的约束违反。因此，我们增加了一个误差校正项。我们构造了一个具有对角矩阵$K_c$的<em>P-controller</em>。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}\ddot{\boldsymbol{q}}_E\\\dot{\boldsymbol{\mu}}_E\end{bmatrix}=-\boldsymbol{J}_c^\dagger\boldsymbol{K}_c\boldsymbol{c}(\boldsymbol{q},\dot{\boldsymbol{q}},\boldsymbol{\mu})    \tag{10}</script><p>将式(9)与式(10)结合，得到作用于系统的关节加速度：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}\ddot{\boldsymbol{q}}\\\dot{\boldsymbol{\mu}}\end{bmatrix}=-\boldsymbol{J}_c^\dagger(\boldsymbol{q},\boldsymbol{\mu})\left[\boldsymbol{K}_c\boldsymbol{c}(\boldsymbol{q},\dot{\boldsymbol{q}},\boldsymbol{\mu})+\boldsymbol{\psi}(\boldsymbol{q},\dot{\boldsymbol{q}})\right]+\boldsymbol{N}_c(\boldsymbol{q},\boldsymbol{\mu})\boldsymbol{\alpha}    \tag{11}</script><p>RHS上的第一项是维持约束条件所需的加速度/速度RHS上的第二项是可以自由探索的正切加速度。图5给出了圆约束的误差校正项和零空间项的向量场。灰色曲线表示采样轨迹由于误差修正而收敛到约束流形。</p>
<p>控制作用可由不同级别的$\boldsymbol{a}=\boldsymbol{\Lambda}(\ddot{\boldsymbol{q}})$确定。例如，我们可以使用逆动力学模型来计算通过扭矩命令控制机器人时的关节扭矩。我们也可以应用积分方法来确定期望的位置/速度，然后使用足够精确的跟踪控制器(例如PID控制器+前馈项)来跟踪期望的轨迹。</p>
<p><img src="/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/3.png" alt="3"></p>
<h2 id="Null-Space-Convention"><a href="#Null-Space-Convention" class="headerlink" title="Null Space Convention"></a>Null Space Convention</h2><p>正交零空间矩阵$N_c$可以通过<em>SVD</em>或<em>QR</em>分解来确定。然而，零空间基的表示并不是唯一的。采用数值分解方法计算的零空间基很难保持一致性。为了解决这个问题，文章提出了一个保证零空间基唯一性的约定。</p>
<p>零空间矩阵$N_c$的每一列是一个单位向量，表示方向为$[\ddot q \ \dot u]$。然而，这个单位矢量有时可能主要贡献于松弛变量的部分，关节加速度的项可能非常小。因此，由$\alpha \in [\alpha_{min}, \alpha_{max}]$得到的关节加速度只能覆盖加速度的一小部分。如图4所示，红色箭头为切空间的单位基向量，通过通用比例因子得到的可达关节加速度只能覆盖部分可行关节加速度，如图4所示红色区域。为了缓解前面提到的问题，我们计算零空间矩阵$N_{c}^{R}=RCEF(N_c)$的简化列梯形（Reduced Column Echlon Form, RCEF）。给定矩阵的 <em>RCEF</em> 是唯一的，我们得到零空间的唯一基。此外，对于RCEF，包含前导1的每行在其所有其他条目中都有零。一般来说，存在N个独立的关节，它们的加速度可以由$\alpha$单独决定，其中N是零空间的维数。</p>
<p>也可以定义$\alpha$的可行范围为$\alpha \in [\ddot q_{i, min}, \ddot q_{i, min}]$。通过这种约定，关节加速度能够覆盖整个可行范围。零空间基和可行域如图4中蓝色向量和蓝色区域所示。</p>
<p>ATACOM算法流程：</p>
<p><img src="/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/4.png" alt="4"></p>
<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/102-2023-08-27-Paper-RLConstraintManifold.pdf">RL in Constraint Manifold.pdf</a></p>
<p>引用：Liu P, Tateo D, Ammar H B, et al. Robot reinforcement learning on the constraint manifold[C]//Conference on Robot Learning. PMLR, 2022: 1357-1366.</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Arvin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/">http://example.com/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Arvin</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/09/05/301-2023-09-05-Math-LieGroup/" title="李群李代数（一）"><img class="cover" src="https://arvinzyj.github.io/2023/09/05/301-2023-09-05-Math-LieGroup/0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">李群李代数（一）</div></div><div class="info-2"><div class="info-item-1">文档维护：Arvin 网页部署：Arvin ▶ 写在前面：这篇的内容主要来自于《slam十四讲：从入门到实践》中的第三、四章，是为了引出李群李代数，文章大多记录了一些结论，如果对推导有兴趣可以去看书中详细的过程。  基础知识三维空间刚体运动旋转矩阵1.反对称矩阵 设$A=(a_{ij})_{n \times n}$，若其中元素满足$a_{ij}=a_{ji},\forall i,j\Leftrightarrow A^T=A$，则称$A$是对称矩阵；若其元素满足$a_{ij}=-a_{ji},\forall i,j\Leftrightarrow A^T=-A$，则称$A$为反对称矩阵。 若$A$是反对称矩阵，则$a_{ij}=-a_{ij}$，当$i=j$时，便有$a_{ij}=0$，即反对称矩阵对角线上的元全为零，而位于主对角线两侧对称的元素反号。 2.旋转矩阵 欧氏变换由旋转和平移组成。我们首先考虑旋转。设某个单位正交基$(e_1, e_2, e_3)$经过一次旋转变成了$(e^{\prime}_1, e^{\prime}_2, e^{\prime}_3)$。那么，对于同一个向...</div></div></div></a><a class="pagination-related" href="/2023/07/19/101-2023-07-19-Paper-Adam/" title="Adam"><img class="cover" src="/img/cover-img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Adam</div></div><div class="info-2"><div class="info-item-1">文档维护：Arvin 网页部署：Arvin ▶ Abstract介绍了一种基于低阶矩自适应估计的随机目标函数一阶梯度优化算法Adam。该方法易于实现，计算效率高，内存需求少，对梯度的对角线重新缩放不变，非常适合数据和参数量大的问题。 该方法也适用于非平稳目标和具有非常嘈杂和/或稀疏梯度的问题。超参数有直观的解释，通常不需要调优。讨论了一些与相关算法的联系，这些算法是Adam的灵感来源。我们还分析了算法的理论收敛性，并给出了与在线凸优化框架下的最知名结果相当的收敛速度遗憾界。实证结果表明，Adam方法在实践中效果良好，优于其他随机优化方法。最后，我们讨论了基于无穷范数的Adam的变体AdaMax。 IntroductionAdam，一种只需要一节梯度且内存需求很小的高效随机优化方法。该方法通过估计梯度的第一阶矩和第二阶矩来计算不同参数的个体自适应学习率。算法伪代码：  参数：  $t$：时间步数 $\alpha$：学习率（步长） $\theta$：参数 $f(\theta)$：目标函数（损失函数） $g_t$：梯度，即$g_t = \frac{\partial f}{\partia...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/nacho.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Arvin</div><div class="author-info-description">世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Abstract"><span class="toc-number">1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Learning-on-the-Constraint-Manifold"><span class="toc-number">3.</span> <span class="toc-text">Learning on the Constraint Manifold</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#State-Constraints"><span class="toc-number">3.1.</span> <span class="toc-text">State Constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Viability-Constraints"><span class="toc-number">3.2.</span> <span class="toc-text">Viability Constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Viability-Acceleration-Bound"><span class="toc-number">3.3.</span> <span class="toc-text">Viability Acceleration Bound</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error-Correction-and-Control-Action-Selection"><span class="toc-number">3.4.</span> <span class="toc-text">Error Correction and Control Action Selection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null-Space-Convention"><span class="toc-number">3.5.</span> <span class="toc-text">Null Space Convention</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/18/503-2025-08-18-Others-HexoBlog/" title="HEXO个人博客搭建"><img src="/img/cover-img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HEXO个人博客搭建"/></a><div class="content"><a class="title" href="/2025/08/18/503-2025-08-18-Others-HexoBlog/" title="HEXO个人博客搭建">HEXO个人博客搭建</a><time datetime="2025-08-17T16:00:00.000Z" title="发表于 2025-08-18 00:00:00">2025-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/09/502-2024-11-09-Others-Ubuntu/" title="系统安装"><img src="https://github.com/arvinzyj/arvinzyj.github.io/tree/main/2024/11/09/502-2024-11-09-Others-Ubuntu/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="系统安装"/></a><div class="content"><a class="title" href="/2024/11/09/502-2024-11-09-Others-Ubuntu/" title="系统安装">系统安装</a><time datetime="2024-11-08T16:00:00.000Z" title="发表于 2024-11-09 00:00:00">2024-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/08/309-2024-04-08-Math-AutoDriver/" title="自动驾驶预测与决策规划（三）"><img src="/img/cover-img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动驾驶预测与决策规划（三）"/></a><div class="content"><a class="title" href="/2024/04/08/309-2024-04-08-Math-AutoDriver/" title="自动驾驶预测与决策规划（三）">自动驾驶预测与决策规划（三）</a><time datetime="2024-04-07T16:00:00.000Z" title="发表于 2024-04-08 00:00:00">2024-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/20/308-2024-03-20-Math-AutoDriver/" title="自动驾驶预测与决策规划（二）"><img src="/img/cover-img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动驾驶预测与决策规划（二）"/></a><div class="content"><a class="title" href="/2024/03/20/308-2024-03-20-Math-AutoDriver/" title="自动驾驶预测与决策规划（二）">自动驾驶预测与决策规划（二）</a><time datetime="2024-03-19T16:00:00.000Z" title="发表于 2024-03-20 00:00:00">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/10/307-2024-03-10-Math-AutoDriver/" title="自动驾驶预测与决策规划（一）"><img src="/img/cover-img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动驾驶预测与决策规划（一）"/></a><div class="content"><a class="title" href="/2024/03/10/307-2024-03-10-Math-AutoDriver/" title="自动驾驶预测与决策规划（一）">自动驾驶预测与决策规划（一）</a><time datetime="2024-03-09T16:00:00.000Z" title="发表于 2024-03-10 00:00:00">2024-03-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://arvinzyj.github.io/2023/08/28/102-2023-08-27-Paper-RLConstraintManifold/1.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Arvin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>